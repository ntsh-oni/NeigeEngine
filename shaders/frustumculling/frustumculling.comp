#version 460

layout(local_size_x = 64) in;

struct DrawIndirect {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	int firstInstance;
};

struct PerDraw {
	int materialIndex;
	float alphaCutoff;
};

struct AABB {
	vec3 min;
	vec3 max;
};

// Read only
layout(set = 0, binding = 0) restrict readonly buffer InDrawIndirect {
	DrawIndirect drawIndirect[];
} iDI;

layout(set = 0, binding = 1) restrict readonly buffer InPerDraw {
	PerDraw perDraw[];
} iPerDraw;

layout(set = 0, binding = 2) restrict readonly buffer InAABB {
	AABB aabb[];
} iAABB;

layout(set = 0, binding = 3) uniform InFrustum {
	vec4 frustum[6];
} iF;

layout(push_constant) uniform DrawCount {
	uint drawCount;
} iDC;

// Write
layout(set = 0, binding = 4) restrict writeonly buffer OutDrawIndirect {
	DrawIndirect drawIndirect[];
} oDI;

layout(set = 0, binding = 5) restrict writeonly buffer OutPerDraw {
	PerDraw perDraw[];
} oPerDraw;

layout(set = 0, binding = 6) buffer OutDrawCount {
	uint drawCount;
} oDC;

bool collision(uint objectID) {
	vec3 Mmm = vec3(iAABB.aabb[objectID].max.x, iAABB.aabb[objectID].min.y, iAABB.aabb[objectID].min.z);
	vec3 mMm = vec3(iAABB.aabb[objectID].min.x, iAABB.aabb[objectID].max.y, iAABB.aabb[objectID].min.z);
	vec3 MMm = vec3(iAABB.aabb[objectID].max.x, iAABB.aabb[objectID].max.y, iAABB.aabb[objectID].min.z);
	vec3 mmM = vec3(iAABB.aabb[objectID].min.x, iAABB.aabb[objectID].min.y, iAABB.aabb[objectID].max.z);
	vec3 MmM = vec3(iAABB.aabb[objectID].max.x, iAABB.aabb[objectID].min.y, iAABB.aabb[objectID].max.z);
	vec3 mMM = vec3(iAABB.aabb[objectID].min.x, iAABB.aabb[objectID].max.y, iAABB.aabb[objectID].max.z);
	for (int i = 0; i < 6; i++) {
		if (((dot(iF.frustum[i].xyz, iAABB.aabb[objectID].min) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, Mmm) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, mMm) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, MMm) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, mmM) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, MmM) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, mMM) + iF.frustum[i].w) <= 0.0f)
			&& ((dot(iF.frustum[i].xyz, iAABB.aabb[objectID].max) + iF.frustum[i].w) <= 0.0f)) {
			return false;
		}
	}

	return true;
}

void main() {
	uint dI = gl_GlobalInvocationID.x;
	
	if (dI >= iDC.drawCount) {
		return;
	}
	
	if (collision(dI)) {
		uint dCI = atomicAdd(oDC.drawCount, 1);
		
		oDI.drawIndirect[dCI].indexCount = iDI.drawIndirect[dI].indexCount;
		oDI.drawIndirect[dCI].instanceCount = iDI.drawIndirect[dI].instanceCount;
		oDI.drawIndirect[dCI].firstIndex = iDI.drawIndirect[dI].firstIndex;
		oDI.drawIndirect[dCI].vertexOffset = iDI.drawIndirect[dI].vertexOffset;
		oDI.drawIndirect[dCI].firstInstance = iDI.drawIndirect[dI].firstInstance;
		
		oPerDraw.perDraw[dCI].materialIndex = iPerDraw.perDraw[dI].materialIndex; 
		oPerDraw.perDraw[dCI].alphaCutoff = iPerDraw.perDraw[dI].alphaCutoff; 
	}
}